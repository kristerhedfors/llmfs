"""README generator that creates filesystem tree documentation."""
from typing import Dict, List
from ...models.filesystem import FileNode
from .proc import ProcPlugin

class ReadmeGenerator(ProcPlugin):
    """Generator that creates README in .llmfs directory with filesystem tree structure."""
    
    def generator_name(self) -> str:
        return "readme"
    
    def get_proc_path(self) -> str:
        return "readme"
    
    def _build_tree(self, path: str, structure: Dict[str, FileNode], indent: str = "") -> List[str]:
        """Build a tree representation of the filesystem structure."""
        result = []
        
        children = structure[path].children or {}
        sorted_names = sorted(children.keys())
        
        for i, name in enumerate(sorted_names):
            child_path = children[name]
            is_last = i == len(sorted_names) - 1
            
            # Choose the appropriate symbols
            prefix = "└── " if is_last else "├── "
            child_indent = indent + ("    " if is_last else "│   ")
            
            # Build the line with file name and status
            child_node = structure[child_path]
            line = f"{indent}{prefix}{name}"
            
            if child_node.type == "file":
                # Add appropriate spacing
                line += " " * max(1, 40 - len(line))  # Ensure at least one space
                
                if child_node.xattrs and "generator" in child_node.xattrs:
                    line += f"[Auto-generated by {child_node.xattrs['generator']} plugin]"
                else:
                    # Find nearest prompt file using settings function
                    from ...config.settings import find_nearest_prompt_file
                    prompt_path = find_nearest_prompt_file(child_path, structure)
                    prompt_info = f", using {prompt_path[1:]}" if prompt_path else ""
                    line += f"[Generated on first read{prompt_info}]"
                
                result.append(line)
            else:
                result.append(line)
                # Recursively add children if this is a directory
                result.extend(self._build_tree(child_path, structure, child_indent))
        
        return result
    
    def _get_llmfs_overview(self, fs_structure: Dict[str, FileNode]) -> str:
        """Generate overview of .llmfs directory contents."""
        overview = []
        llmfs_dir = "/.llmfs"
        
        if llmfs_dir not in fs_structure:
            return "No .llmfs directory found."
            
        llmfs_files = fs_structure[llmfs_dir].children or {}
        
        overview.append("## .llmfs Directory Overview\n")
        overview.append("The .llmfs directory contains special files that control and monitor the filesystem:\n")
        
        file_descriptions = {
            "model.default": "Specifies the OpenAI model used for content generation. Can be set using JSON format or raw model name. Default: gpt-4o-2024-08-06",
            "prompt.default": "Contains the system prompt template used for content generation. Supports custom prompts per directory and includes best practices for different file types.",
            "readme": "This file - provides filesystem documentation and structure overview. Auto-updates when filesystem changes.",
            "tree": "Provides a structured, greppable tree visualization of the filesystem, showing which plugins generate each file's content.",
            "log": "Provides access to the LLMFS log file (/var/log/llmfs/llmfs.log) for monitoring system activity and debugging."
        }
        
        for name, path in sorted(llmfs_files.items()):
            node = fs_structure[path]
            overview.append(f"\n### {name}")
            
            # Add file description
            if name in file_descriptions:
                overview.append(f"\n{file_descriptions[name]}")
            
            # Add generator info if available
            if node.xattrs and "generator" in node.xattrs:
                overview.append(f"\nManaged by: {node.xattrs['generator']} plugin")
            
            # Add preview of current content if available
            if node.content:
                content_preview = node.content.strip()[:200]
                if len(node.content) > 200:
                    content_preview += "..."
                overview.append(f"\nCurrent content preview:\n```\n{content_preview}\n```")
        
        return "\n".join(overview)

    def generate(self, path: str, node: FileNode, fs_structure: Dict[str, FileNode]) -> str:
        """Generate a readme with filesystem structure and .llmfs overview."""
        # Force update of filesystem structure before generating
        tree_lines = self._build_tree("/", fs_structure)
        tree_str = "\n".join(tree_lines)
        llmfs_overview = self._get_llmfs_overview(fs_structure)
        
        return f"""# Project Structure

This directory contains the following structure:

{tree_str}

Files in the tree are marked in two ways:
- "[Auto-generated by ...]" indicates files whose content is dynamically generated by a plugin on every read
- "[Generated on first read]" indicates files whose content is generated when first accessed and then cached

{llmfs_overview}

## Usage Tips

1. **Model Selection**
   - Edit model.default to change the OpenAI model
   - Use JSON format for additional settings
   - Or simply write the model name directly

2. **Content Generation**
   - Default generator handles most files
   - Uses nearest prompt.default for context
   - Temperature 0.2 for consistent output

3. **System Monitoring**
   - View logs through .llmfs/log
   - Check filesystem structure with .llmfs/tree
   - Monitor file generation status in readme

4. **Custom Prompts**
   - Create prompt.default in any directory
   - Inherits from parent if not found
   - Supports best practices templates

5. **File Generation**
   - Plugin-managed files: Content regenerated on every read (e.g., .llmfs/model.default)
   - Default files: Content generated and cached on first read (e.g., /etc/fstab)
   - Both types use context-aware generation based on filesystem state

The .llmfs directory provides a centralized location for controlling and monitoring
the filesystem's behavior. Files in this directory are automatically updated to
reflect the current system state.
"""
